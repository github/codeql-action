import { OpenCensusTraceStateWrapper } from "./openCensusTraceStateWrapper";
function isWrappedSpan(span) {
    return !!span && span.getWrappedSpan !== undefined;
}
function isTracer(tracerOrSpan) {
    return tracerOrSpan.getWrappedTracer !== undefined;
}
/**
 * An implementation of OpenTelemetry Span that wraps an OpenCensus Span.
 */
var OpenCensusSpanWrapper = /** @class */ (function () {
    function OpenCensusSpanWrapper(tracerOrSpan, name, options) {
        if (name === void 0) { name = ""; }
        if (options === void 0) { options = {}; }
        if (isTracer(tracerOrSpan)) {
            var parent = isWrappedSpan(options.parent) ? options.parent.getWrappedSpan() : undefined;
            this._span = tracerOrSpan.getWrappedTracer().startChildSpan({
                name: name,
                childOf: parent
            });
            this._span.start();
            if (options.links) {
                for (var _i = 0, _a = options.links; _i < _a.length; _i++) {
                    var link = _a[_i];
                    // Since there is no way to set the link relationship, leave it as Unspecified.
                    this._span.addLink(link.context.traceId, link.context.spanId, 0 /* LinkType.UNSPECIFIED */, link.attributes);
                }
            }
        }
        else {
            this._span = tracerOrSpan;
        }
    }
    /**
     * The underlying OpenCensus Span
     */
    OpenCensusSpanWrapper.prototype.getWrappedSpan = function () {
        return this._span;
    };
    /**
     * Marks the end of Span execution.
     * @param endTime The time to use as the Span's end time. Defaults to
     * the current time.
     */
    OpenCensusSpanWrapper.prototype.end = function (_endTime) {
        this._span.end();
    };
    /**
     * Returns the SpanContext associated with this Span.
     */
    OpenCensusSpanWrapper.prototype.context = function () {
        var openCensusSpanContext = this._span.spanContext;
        return {
            spanId: openCensusSpanContext.spanId,
            traceId: openCensusSpanContext.traceId,
            traceFlags: openCensusSpanContext.options,
            traceState: new OpenCensusTraceStateWrapper(openCensusSpanContext.traceState)
        };
    };
    /**
     * Sets an attribute on the Span
     * @param key the attribute key
     * @param value the attribute value
     */
    OpenCensusSpanWrapper.prototype.setAttribute = function (key, value) {
        this._span.addAttribute(key, value);
        return this;
    };
    /**
     * Sets attributes on the Span
     * @param attributes the attributes to add
     */
    OpenCensusSpanWrapper.prototype.setAttributes = function (attributes) {
        this._span.attributes = attributes;
        return this;
    };
    /**
     * Adds an event to the Span
     * @param name The name of the event
     * @param attributes The associated attributes to add for this event
     */
    OpenCensusSpanWrapper.prototype.addEvent = function (_name, _attributes) {
        throw new Error("Method not implemented.");
    };
    /**
     * Sets a status on the span. Overrides the default of CanonicalCode.OK.
     * @param status The status to set.
     */
    OpenCensusSpanWrapper.prototype.setStatus = function (status) {
        this._span.setStatus(status.code, status.message);
        return this;
    };
    /**
     * Updates the name of the Span
     * @param name the new Span name
     */
    OpenCensusSpanWrapper.prototype.updateName = function (name) {
        this._span.name = name;
        return this;
    };
    /**
     * Returns whether this span will be recorded
     */
    OpenCensusSpanWrapper.prototype.isRecording = function () {
        // NoRecordSpans have an empty traceId
        return !!this._span.traceId;
    };
    return OpenCensusSpanWrapper;
}());
export { OpenCensusSpanWrapper };
//# sourceMappingURL=openCensusSpanWrapper.js.map