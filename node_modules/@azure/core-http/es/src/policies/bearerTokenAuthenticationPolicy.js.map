{"version":3,"file":"bearerTokenAuthenticationPolicy.js","sourceRoot":"","sources":["../../../src/policies/bearerTokenAuthenticationPolicy.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;;AAGlC,OAAO,EACL,iBAAiB,EAIlB,MAAM,2BAA2B,CAAC;AACnC,OAAO,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAC;AAE9C,OAAO,EAAE,WAAW,EAAE,MAAM,gBAAgB,CAAC;AAE7C,OAAO,EAAoB,wBAAwB,EAAE,MAAM,iCAAiC,CAAC;AAC7F,OAAO,EAAE,oBAAoB,EAAE,MAAM,qCAAqC,CAAC;AAE3E;;;;;GAKG;AACH,MAAM,UAAU,+BAA+B,CAC7C,UAA2B,EAC3B,MAAyB;IAEzB,IAAM,UAAU,GAAqB,IAAI,wBAAwB,EAAE,CAAC;IACpE,IAAM,cAAc,GAAG,IAAI,oBAAoB,CAC7C,UAAU,EACV,MAAM,EACN,8BAA8B,CAC/B,CAAC;IAEF,OAAO;QACL,MAAM,EAAE,UAAC,UAAyB,EAAE,OAA6B;YAC/D,OAAO,IAAI,+BAA+B,CAAC,UAAU,EAAE,OAAO,EAAE,UAAU,EAAE,cAAc,CAAC,CAAC;QAC9F,CAAC;KACF,CAAC;AACJ,CAAC;AAED;;;;GAIG;AACH,IAAM,8BAA8B,GAAG,KAAK,CAAC;AAE7C;;;;;;GAMG;AACH;IAAqD,mDAAiB;IACpE;;;;;;;;OAQG;IACH,yCACE,UAAyB,EACzB,OAA6B,EACrB,UAA4B,EAC5B,cAAoC;QAJ9C,YAME,kBAAM,UAAU,EAAE,OAAO,CAAC,SAC3B;QAJS,gBAAU,GAAV,UAAU,CAAkB;QAC5B,oBAAc,GAAd,cAAc,CAAsB;;IAG9C,CAAC;IAED;;;OAGG;IACU,qDAAW,GAAxB,UAAyB,WAA4B;;;;;;wBACnD,IAAI,CAAC,WAAW,CAAC,OAAO;4BAAE,WAAW,CAAC,OAAO,GAAG,IAAI,WAAW,EAAE,CAAC;wBACpD,qBAAM,IAAI,CAAC,QAAQ,CAAC;gCAChC,WAAW,EAAE,WAAW,CAAC,WAAW;gCACpC,cAAc,EAAE;oCACd,WAAW,EAAE,WAAW,CAAC,WAAW;iCACrC;6BACF,CAAC,EAAA;;wBALI,KAAK,GAAG,SAKZ;wBACF,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,eAAe,CAAC,aAAa,EAAE,YAAU,KAAO,CAAC,CAAC;wBACpF,sBAAO,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,WAAW,CAAC,EAAC;;;;KAClD;IAED;;OAEG;IACW,6DAAmB,GAAjC,UAAkC,OAAwB;;;;;;6BACpD,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,EAA7B,wBAA6B;wBACX,qBAAM,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,OAAO,CAAC,EAAA;;wBAAxD,WAAW,GAAG,SAA0C;wBAC9D,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;;;;;;KAE/C;IAEa,kDAAQ,GAAtB,UAAuB,OAAwB;;;;;;wBACzC,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,CAAC;6BAC/C,CAAA,WAAW,KAAK,SAAS,CAAA,EAAzB,wBAAyB;wBAGb,qBAAM,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,OAAO,CAAC,EAAA;;wBAFxD,yFAAyF;wBACzF,6DAA6D;wBAC7D,WAAW,GAAG,SAA0C,CAAC;wBACzD,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;;;wBAE5C,0CAA0C;wBAC1C,+FAA+F;wBAC/F,2CAA2C;wBAC3C,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC;;4BAGpC,sBAAO,WAAW,CAAC,CAAC,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,EAAC;;;;KACpD;IACH,sCAAC;AAAD,CAAC,AA7DD,CAAqD,iBAAiB,GA6DrE","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TokenCredential, GetTokenOptions } from \"@azure/core-auth\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyOptions,\n  RequestPolicyFactory\n} from \"../policies/requestPolicy\";\nimport { Constants } from \"../util/constants\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { HttpHeaders } from \"../httpHeaders\";\nimport { WebResourceLike } from \"../webResource\";\nimport { AccessTokenCache, ExpiringAccessTokenCache } from \"../credentials/accessTokenCache\";\nimport { AccessTokenRefresher } from \"../credentials/accessTokenRefresher\";\n\n/**\n * Creates a new BearerTokenAuthenticationPolicy factory.\n *\n * @param credential The TokenCredential implementation that can supply the bearer token.\n * @param scopes The scopes for which the bearer token applies.\n */\nexport function bearerTokenAuthenticationPolicy(\n  credential: TokenCredential,\n  scopes: string | string[]\n): RequestPolicyFactory {\n  const tokenCache: AccessTokenCache = new ExpiringAccessTokenCache();\n  const tokenRefresher = new AccessTokenRefresher(\n    credential,\n    scopes,\n    timeBetweenRefreshAttemptsInMs\n  );\n\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new BearerTokenAuthenticationPolicy(nextPolicy, options, tokenCache, tokenRefresher);\n    }\n  };\n}\n\n/**\n * The automated token refresh will only start to happen at the\n * expiration date minus the value of timeBetweenRefreshAttemptsInMs,\n * which is by default 30 seconds.\n */\nconst timeBetweenRefreshAttemptsInMs = 30000;\n\n/**\n *\n * Provides a RequestPolicy that can request a token from a TokenCredential\n * implementation and then apply it to the Authorization header of a request\n * as a Bearer token.\n *\n */\nexport class BearerTokenAuthenticationPolicy extends BaseRequestPolicy {\n  /**\n   * Creates a new BearerTokenAuthenticationPolicy object.\n   *\n   * @param nextPolicy The next RequestPolicy in the request pipeline.\n   * @param options Options for this RequestPolicy.\n   * @param credential The TokenCredential implementation that can supply the bearer token.\n   * @param scopes The scopes for which the bearer token applies.\n   * @param tokenCache The cache for the most recent AccessToken returned from the TokenCredential.\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    private tokenCache: AccessTokenCache,\n    private tokenRefresher: AccessTokenRefresher\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Applies the Bearer token to the request through the Authorization header.\n   * @param webResource\n   */\n  public async sendRequest(webResource: WebResourceLike): Promise<HttpOperationResponse> {\n    if (!webResource.headers) webResource.headers = new HttpHeaders();\n    const token = await this.getToken({\n      abortSignal: webResource.abortSignal,\n      tracingOptions: {\n        spanOptions: webResource.spanOptions\n      }\n    });\n    webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${token}`);\n    return this._nextPolicy.sendRequest(webResource);\n  }\n\n  /**\n   * Attempts a token update if any other time related conditionals have been reached based on the tokenRefresher class.\n   */\n  private async updateTokenIfNeeded(options: GetTokenOptions): Promise<void> {\n    if (this.tokenRefresher.isReady()) {\n      const accessToken = await this.tokenRefresher.refresh(options);\n      this.tokenCache.setCachedToken(accessToken);\n    }\n  }\n\n  private async getToken(options: GetTokenOptions): Promise<string | undefined> {\n    let accessToken = this.tokenCache.getCachedToken();\n    if (accessToken === undefined) {\n      // Waiting for the next refresh only if the cache is unable to retrieve the access token,\n      // which means that it has expired, or it has never been set.\n      accessToken = await this.tokenRefresher.refresh(options);\n      this.tokenCache.setCachedToken(accessToken);\n    } else {\n      // If we still have a cached access token,\n      // And any other time related conditionals have been reached based on the tokenRefresher class,\n      // then attempt to refresh without waiting.\n      this.updateTokenIfNeeded(options);\n    }\n\n    return accessToken ? accessToken.token : undefined;\n  }\n}\n"]}