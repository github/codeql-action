{"version":3,"file":"xml.browser.js","sourceRoot":"","sources":["../../../src/util/xml.browser.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { XML_ATTRKEY, XML_CHARKEY, SerializerOptions } from \"./serializer.common\";\n\n// tslint:disable-next-line:no-null-keyword\nconst doc = document.implementation.createDocument(null, null, null);\n\nconst parser = new DOMParser();\nexport function parseXML(str: string, opts: SerializerOptions = {}): Promise<any> {\n  try {\n    const updatedOptions: Required<SerializerOptions> = {\n      rootName: opts.rootName ?? \"\",\n      includeRoot: opts.includeRoot ?? false,\n      xmlCharKey: opts.xmlCharKey ?? XML_CHARKEY\n    };\n    const dom = parser.parseFromString(str, \"application/xml\");\n    throwIfError(dom);\n\n    let obj;\n    if (updatedOptions.includeRoot) {\n      obj = domToObject(dom, updatedOptions);\n    } else {\n      obj = domToObject(dom.childNodes[0], updatedOptions);\n    }\n\n    return Promise.resolve(obj);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\n\nlet errorNS = \"\";\ntry {\n  errorNS = parser.parseFromString(\"INVALID\", \"text/xml\").getElementsByTagName(\"parsererror\")[0]\n    .namespaceURI!;\n} catch (ignored) {\n  // Most browsers will return a document containing <parsererror>, but IE will throw.\n}\n\nfunction throwIfError(dom: Document): void {\n  if (errorNS) {\n    const parserErrors = dom.getElementsByTagNameNS(errorNS, \"parsererror\");\n    if (parserErrors.length) {\n      throw new Error(parserErrors.item(0)!.innerHTML);\n    }\n  }\n}\n\nfunction isElement(node: Node): node is Element {\n  return !!(node as Element).attributes;\n}\n\n/**\n * Get the Element-typed version of the provided Node if the provided node is an element with\n * attributes. If it isn't, then undefined is returned.\n */\nfunction asElementWithAttributes(node: Node): Element | undefined {\n  return isElement(node) && node.hasAttributes() ? node : undefined;\n}\n\nfunction domToObject(node: Node, options: Required<SerializerOptions>): any {\n  let result: any = {};\n\n  const childNodeCount: number = node.childNodes.length;\n\n  const firstChildNode: Node = node.childNodes[0];\n  const onlyChildTextValue: string | undefined =\n    (firstChildNode &&\n      childNodeCount === 1 &&\n      firstChildNode.nodeType === Node.TEXT_NODE &&\n      firstChildNode.nodeValue) ||\n    undefined;\n\n  const elementWithAttributes: Element | undefined = asElementWithAttributes(node);\n  if (elementWithAttributes) {\n    result[XML_ATTRKEY] = {};\n\n    for (let i = 0; i < elementWithAttributes.attributes.length; i++) {\n      const attr = elementWithAttributes.attributes[i];\n      result[XML_ATTRKEY][attr.nodeName] = attr.nodeValue;\n    }\n\n    if (onlyChildTextValue) {\n      result[options.xmlCharKey] = onlyChildTextValue;\n    }\n  } else if (childNodeCount === 0) {\n    result = \"\";\n  } else if (onlyChildTextValue) {\n    result = onlyChildTextValue;\n  }\n\n  if (!onlyChildTextValue) {\n    for (let i = 0; i < childNodeCount; i++) {\n      const child = node.childNodes[i];\n      // Ignore leading/trailing whitespace nodes\n      if (child.nodeType !== Node.TEXT_NODE) {\n        const childObject: any = domToObject(child, options);\n        if (!result[child.nodeName]) {\n          result[child.nodeName] = childObject;\n        } else if (Array.isArray(result[child.nodeName])) {\n          result[child.nodeName].push(childObject);\n        } else {\n          result[child.nodeName] = [result[child.nodeName], childObject];\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nconst serializer = new XMLSerializer();\n\nexport function stringifyXML(content: any, opts: SerializerOptions = {}): string {\n  const updatedOptions: Required<SerializerOptions> = {\n    rootName: opts.rootName ?? \"root\",\n    includeRoot: opts.includeRoot ?? false,\n    xmlCharKey: opts.xmlCharKey ?? XML_CHARKEY\n  };\n  const dom = buildNode(content, updatedOptions.rootName, updatedOptions)[0];\n  return (\n    '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + serializer.serializeToString(dom)\n  );\n}\n\nfunction buildAttributes(attrs: { [key: string]: { toString(): string } }): Attr[] {\n  const result = [];\n  for (const key of Object.keys(attrs)) {\n    const attr = doc.createAttribute(key);\n    attr.value = attrs[key].toString();\n    result.push(attr);\n  }\n  return result;\n}\n\nfunction buildNode(obj: any, elementName: string, options: Required<SerializerOptions>): Node[] {\n  if (\n    obj === undefined ||\n    obj === null ||\n    typeof obj === \"string\" ||\n    typeof obj === \"number\" ||\n    typeof obj === \"boolean\"\n  ) {\n    const elem = doc.createElement(elementName);\n    elem.textContent = obj === undefined || obj === null ? \"\" : obj.toString();\n    return [elem];\n  } else if (Array.isArray(obj)) {\n    const result = [];\n    for (const arrayElem of obj) {\n      for (const child of buildNode(arrayElem, elementName, options)) {\n        result.push(child);\n      }\n    }\n    return result;\n  } else if (typeof obj === \"object\") {\n    const elem = doc.createElement(elementName);\n    for (const key of Object.keys(obj)) {\n      if (key === XML_ATTRKEY) {\n        for (const attr of buildAttributes(obj[key])) {\n          elem.attributes.setNamedItem(attr);\n        }\n      } else if (key === options.xmlCharKey) {\n        elem.textContent = obj[key].toString();\n      } else {\n        for (const child of buildNode(obj[key], key, options)) {\n          elem.appendChild(child);\n        }\n      }\n    }\n    return [elem];\n  } else {\n    throw new Error(`Illegal value passed to buildObject: ${obj}`);\n  }\n}\n"]}