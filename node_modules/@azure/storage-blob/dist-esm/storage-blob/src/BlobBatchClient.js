// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __assign, __awaiter, __generator } from "tslib";
import { BatchResponseParser } from "./BatchResponseParser";
import { utf8ByteLength } from "./BatchUtils";
import { BlobBatch } from "./BlobBatch";
import { CanonicalCode } from "@opentelemetry/api";
import { createSpan } from "./utils/tracing";
import { Service } from "./generated/src/operations";
import { AnonymousCredential } from "./credentials/AnonymousCredential";
import { StorageClientContext } from "./generated/src/storageClientContext";
import { Pipeline, newPipeline } from "./Pipeline";
/**
 * A BlobBatchClient allows you to make batched requests to the Azure Storage Blob service.
 *
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch
 */
var BlobBatchClient = /** @class */ (function () {
    function BlobBatchClient(url, credentialOrPipeline, options) {
        var pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (!credentialOrPipeline) {
            // no credential provided
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        else {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        var storageClientContext = new StorageClientContext(url, pipeline.toServiceClientOptions());
        this._serviceContext = new Service(storageClientContext);
    }
    /**
     * Creates a {@link BlobBatch}.
     * A BlobBatch represents an aggregated set of operations on blobs.
     */
    BlobBatchClient.prototype.createBatch = function () {
        return new BlobBatch();
    };
    BlobBatchClient.prototype.deleteBlobs = function (urlsOrBlobClients, credentialOrOptions, options) {
        return __awaiter(this, void 0, void 0, function () {
            var batch, _i, urlsOrBlobClients_1, urlOrBlobClient;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        batch = new BlobBatch();
                        _i = 0, urlsOrBlobClients_1 = urlsOrBlobClients;
                        _a.label = 1;
                    case 1:
                        if (!(_i < urlsOrBlobClients_1.length)) return [3 /*break*/, 6];
                        urlOrBlobClient = urlsOrBlobClients_1[_i];
                        if (!(typeof urlOrBlobClient === "string")) return [3 /*break*/, 3];
                        return [4 /*yield*/, batch.deleteBlob(urlOrBlobClient, credentialOrOptions, options)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, batch.deleteBlob(urlOrBlobClient, credentialOrOptions)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        _i++;
                        return [3 /*break*/, 1];
                    case 6: return [2 /*return*/, this.submitBatch(batch)];
                }
            });
        });
    };
    BlobBatchClient.prototype.setBlobsAccessTier = function (urlsOrBlobClients, credentialOrTier, tierOrOptions, options) {
        return __awaiter(this, void 0, void 0, function () {
            var batch, _i, urlsOrBlobClients_2, urlOrBlobClient;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        batch = new BlobBatch();
                        _i = 0, urlsOrBlobClients_2 = urlsOrBlobClients;
                        _a.label = 1;
                    case 1:
                        if (!(_i < urlsOrBlobClients_2.length)) return [3 /*break*/, 6];
                        urlOrBlobClient = urlsOrBlobClients_2[_i];
                        if (!(typeof urlOrBlobClient === "string")) return [3 /*break*/, 3];
                        return [4 /*yield*/, batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        _i++;
                        return [3 /*break*/, 1];
                    case 6: return [2 /*return*/, this.submitBatch(batch)];
                }
            });
        });
    };
    /**
     * Submit batch request which consists of multiple subrequests.
     *
     * Get `blobBatchClient` and other details before running the snippets.
     * `blobServiceClient.getBlobBatchClient()` gives the `blobBatchClient`
     *
     * Example usage:
     *
     * ```js
     * let batchRequest = new BlobBatch();
     * await batchRequest.deleteBlob(urlInString0, credential0);
     * await batchRequest.deleteBlob(urlInString1, credential1, {
     *  deleteSnapshots: "include"
     * });
     * const batchResp = await blobBatchClient.submitBatch(batchRequest);
     * console.log(batchResp.subResponsesSucceededCount);
     * ```
     *
     * Example using a lease:
     *
     * ```js
     * let batchRequest = new BlobBatch();
     * await batchRequest.setBlobAccessTier(blockBlobClient0, "Cool");
     * await batchRequest.setBlobAccessTier(blockBlobClient1, "Cool", {
     *  conditions: { leaseId: leaseId }
     * });
     * const batchResp = await blobBatchClient.submitBatch(batchRequest);
     * console.log(batchResp.subResponsesSucceededCount);
     * ```
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch
     *
     * @param {BlobBatch} batchRequest A set of Delete or SetTier operations.
     * @param {BlobBatchSubmitBatchOptionalParams} [options]
     * @returns {Promise<BlobBatchSubmitBatchResponse>}
     * @memberof BlobBatchClient
     */
    BlobBatchClient.prototype.submitBatch = function (batchRequest, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, batchRequestBody, rawBatchResponse, batchResponseParser, responseSummary, res, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!batchRequest || batchRequest.getSubRequests().size == 0) {
                            throw new RangeError("Batch request should contain one or more sub requests.");
                        }
                        _a = createSpan("BlobBatchClient-submitBatch", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 4, 5, 6]);
                        batchRequestBody = batchRequest.getHttpRequestBody();
                        return [4 /*yield*/, this._serviceContext.submitBatch(batchRequestBody, utf8ByteLength(batchRequestBody), batchRequest.getMultiPartContentType(), __assign(__assign({}, options), { spanOptions: spanOptions }))];
                    case 2:
                        rawBatchResponse = _b.sent();
                        batchResponseParser = new BatchResponseParser(rawBatchResponse, batchRequest.getSubRequests());
                        return [4 /*yield*/, batchResponseParser.parseBatchResponse()];
                    case 3:
                        responseSummary = _b.sent();
                        res = {
                            _response: rawBatchResponse._response,
                            contentType: rawBatchResponse.contentType,
                            errorCode: rawBatchResponse.errorCode,
                            requestId: rawBatchResponse.requestId,
                            clientRequestId: rawBatchResponse.clientRequestId,
                            version: rawBatchResponse.version,
                            subResponses: responseSummary.subResponses,
                            subResponsesSucceededCount: responseSummary.subResponsesSucceededCount,
                            subResponsesFailedCount: responseSummary.subResponsesFailedCount
                        };
                        return [2 /*return*/, res];
                    case 4:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 5:
                        span.end();
                        return [7 /*endfinally*/];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    return BlobBatchClient;
}());
export { BlobBatchClient };
//# sourceMappingURL=BlobBatchClient.js.map