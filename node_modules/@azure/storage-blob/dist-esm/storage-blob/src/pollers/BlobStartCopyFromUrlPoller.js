// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __assign, __awaiter, __extends, __generator } from "tslib";
import { delay } from "@azure/core-http";
import { Poller } from "@azure/core-lro";
/**
 * This is the poller returned by {@link BlobClient.beginCopyFromURL}.
 * This can not be instantiated directly outside of this package.
 *
 * @ignore
 */
var BlobBeginCopyFromUrlPoller = /** @class */ (function (_super) {
    __extends(BlobBeginCopyFromUrlPoller, _super);
    function BlobBeginCopyFromUrlPoller(options) {
        var _this = this;
        var blobClient = options.blobClient, copySource = options.copySource, _a = options.intervalInMs, intervalInMs = _a === void 0 ? 15000 : _a, onProgress = options.onProgress, resumeFrom = options.resumeFrom, startCopyFromURLOptions = options.startCopyFromURLOptions;
        var state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        var operation = makeBlobBeginCopyFromURLPollOperation(__assign(__assign({}, state), { blobClient: blobClient,
            copySource: copySource,
            startCopyFromURLOptions: startCopyFromURLOptions }));
        _this = _super.call(this, operation) || this;
        if (typeof onProgress === "function") {
            _this.onProgress(onProgress);
        }
        _this.intervalInMs = intervalInMs;
        return _this;
    }
    BlobBeginCopyFromUrlPoller.prototype.delay = function () {
        return delay(this.intervalInMs);
    };
    return BlobBeginCopyFromUrlPoller;
}(Poller));
export { BlobBeginCopyFromUrlPoller };
/**
 * Note: Intentionally using function expression over arrow function expression
 * so that the function can be invoked with a different context.
 * This affects what `this` refers to.
 * @ignore
 */
var cancel = function cancel(options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var state, copyId;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    state = this.state;
                    copyId = state.copyId;
                    if (state.isCompleted) {
                        return [2 /*return*/, makeBlobBeginCopyFromURLPollOperation(state)];
                    }
                    if (!copyId) {
                        state.isCancelled = true;
                        return [2 /*return*/, makeBlobBeginCopyFromURLPollOperation(state)];
                    }
                    // if abortCopyFromURL throws, it will bubble up to user's poller.cancelOperation call
                    return [4 /*yield*/, state.blobClient.abortCopyFromURL(copyId, {
                            abortSignal: options.abortSignal
                        })];
                case 1:
                    // if abortCopyFromURL throws, it will bubble up to user's poller.cancelOperation call
                    _a.sent();
                    state.isCancelled = true;
                    return [2 /*return*/, makeBlobBeginCopyFromURLPollOperation(state)];
            }
        });
    });
};
/**
 * Note: Intentionally using function expression over arrow function expression
 * so that the function can be invoked with a different context.
 * This affects what `this` refers to.
 * @ignore
 */
var update = function update(options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var state, blobClient, copySource, startCopyFromURLOptions, result, result, copyStatus, copyProgress, prevCopyProgress, err_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    state = this.state;
                    blobClient = state.blobClient, copySource = state.copySource, startCopyFromURLOptions = state.startCopyFromURLOptions;
                    if (!!state.isStarted) return [3 /*break*/, 2];
                    state.isStarted = true;
                    return [4 /*yield*/, blobClient.startCopyFromURL(copySource, startCopyFromURLOptions)];
                case 1:
                    result = _a.sent();
                    // copyId is needed to abort
                    state.copyId = result.copyId;
                    if (result.copyStatus === "success") {
                        state.result = result;
                        state.isCompleted = true;
                    }
                    return [3 /*break*/, 6];
                case 2:
                    if (!!state.isCompleted) return [3 /*break*/, 6];
                    _a.label = 3;
                case 3:
                    _a.trys.push([3, 5, , 6]);
                    return [4 /*yield*/, state.blobClient.getProperties({ abortSignal: options.abortSignal })];
                case 4:
                    result = _a.sent();
                    copyStatus = result.copyStatus, copyProgress = result.copyProgress;
                    prevCopyProgress = state.copyProgress;
                    if (copyProgress) {
                        state.copyProgress = copyProgress;
                    }
                    if (copyStatus === "pending" &&
                        copyProgress !== prevCopyProgress &&
                        typeof options.fireProgress === "function") {
                        // trigger in setTimeout, or swallow error?
                        options.fireProgress(state);
                    }
                    else if (copyStatus === "success") {
                        state.result = result;
                        state.isCompleted = true;
                    }
                    else if (copyStatus === "failed") {
                        state.error = new Error("Blob copy failed with reason: \"" + (result.copyStatusDescription || "unknown") + "\"");
                        state.isCompleted = true;
                    }
                    return [3 /*break*/, 6];
                case 5:
                    err_1 = _a.sent();
                    state.error = err_1;
                    state.isCompleted = true;
                    return [3 /*break*/, 6];
                case 6: return [2 /*return*/, makeBlobBeginCopyFromURLPollOperation(state)];
            }
        });
    });
};
/**
 * Note: Intentionally using function expression over arrow function expression
 * so that the function can be invoked with a different context.
 * This affects what `this` refers to.
 * @ignore
 */
var toString = function toString() {
    return JSON.stringify({ state: this.state }, function (key, value) {
        // remove blobClient from serialized state since a client can't be hydrated from this info.
        if (key === "blobClient") {
            return undefined;
        }
        return value;
    });
};
/**
 * Creates a poll operation given the provided state.
 * @ignore
 */
function makeBlobBeginCopyFromURLPollOperation(state) {
    return {
        state: __assign({}, state),
        cancel: cancel,
        toString: toString,
        update: update
    };
}
//# sourceMappingURL=BlobStartCopyFromUrlPoller.js.map