{"version":3,"file":"Batch.js","sourceRoot":"","sources":["../../../../src/utils/Batch.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,kCAAkC;;AAElC,8FAA8F;AAC9F,mCAAmC;AACnC,OAAO,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AAOtC;;;;GAIG;AACH,IAAK,WAGJ;AAHD,WAAK,WAAW;IACd,6CAAI,CAAA;IACJ,+CAAK,CAAA;AACP,CAAC,EAHI,WAAW,KAAX,WAAW,QAGf;AAED;;;;;;;GAOG;AACH;IAgEE;;;;OAIG;IACH,eAAmB,WAAuB;QAAvB,4BAAA,EAAA,eAAuB;QA5D1C;;;;;;WAMG;QACK,YAAO,GAAW,CAAC,CAAC;QAE5B;;;;;;WAMG;QACK,cAAS,GAAW,CAAC,CAAC;QAE9B;;;;;;WAMG;QACK,WAAM,GAAW,CAAC,CAAC;QAE3B;;;;;;WAMG;QACK,eAAU,GAAgB,EAAE,CAAC;QAErC;;;;;;;WAOG;QACK,UAAK,GAAgB,WAAW,CAAC,IAAI,CAAC;QAiB5C,IAAI,WAAW,GAAG,CAAC,EAAE;YACnB,MAAM,IAAI,UAAU,CAAC,mCAAmC,CAAC,CAAC;SAC3D;QACD,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,OAAO,GAAG,IAAI,YAAY,EAAE,CAAC;IACpC,CAAC;IAED;;;;;OAKG;IACI,4BAAY,GAAnB,UAAoB,SAAoB;QAAxC,iBAYC;QAXC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;;;;;;wBAEjB,IAAI,CAAC,OAAO,EAAE,CAAC;wBACf,qBAAM,SAAS,EAAE,EAAA;;wBAAjB,SAAiB,CAAC;wBAClB,IAAI,CAAC,OAAO,EAAE,CAAC;wBACf,IAAI,CAAC,SAAS,EAAE,CAAC;wBACjB,IAAI,CAAC,eAAe,EAAE,CAAC;;;;wBAEvB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,OAAK,CAAC,CAAC;;;;;aAErC,CAAC,CAAC;IACL,CAAC;IAED;;;;;OAKG;IACU,kBAAE,GAAf;;;;gBACE,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;oBAChC,sBAAO,OAAO,CAAC,OAAO,EAAE,EAAC;iBAC1B;gBAED,IAAI,CAAC,eAAe,EAAE,CAAC;gBAEvB,sBAAO,IAAI,OAAO,CAAO,UAAC,OAAO,EAAE,MAAM;wBACvC,KAAI,CAAC,OAAO,CAAC,EAAE,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;wBAEnC,KAAI,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,UAAC,KAAK;4BAC7B,KAAI,CAAC,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC;4BAC/B,MAAM,CAAC,KAAK,CAAC,CAAC;wBAChB,CAAC,CAAC,CAAC;oBACL,CAAC,CAAC,EAAC;;;KACJ;IAED;;;;;;OAMG;IACK,6BAAa,GAArB;QACE,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE;YACxC,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;SACvC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;;;OAOG;IACK,+BAAe,GAAvB;QACE,IAAI,IAAI,CAAC,KAAK,KAAK,WAAW,CAAC,KAAK,EAAE;YACpC,OAAO;SACR;QAED,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE;YAC5C,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC5B,OAAO;SACR;QAED,OAAO,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,WAAW,EAAE;YACtC,IAAM,SAAS,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;YACvC,IAAI,SAAS,EAAE;gBACb,SAAS,EAAE,CAAC;aACb;iBAAM;gBACL,OAAO;aACR;SACF;IACH,CAAC;IACH,YAAC;AAAD,CAAC,AAjKD,IAiKC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n// In browser, during webpack or browserify bundling, this module will be replaced by 'events'\n// https://github.com/Gozala/events\nimport { EventEmitter } from \"events\";\n\n/**\n * Operation is an async function to be executed and managed by Batch.\n */\nexport declare type Operation = () => Promise<any>;\n\n/**\n * States for Batch.\n *\n * @enum {number}\n */\nenum BatchStates {\n  Good,\n  Error\n}\n\n/**\n * Batch provides basic parallel execution with concurrency limits.\n * Will stop execute left operations when one of the executed operation throws an error.\n * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.\n *\n * @export\n * @class Batch\n */\nexport class Batch {\n  /**\n   * Concurrency. Must be lager than 0.\n   *\n   * @type {number}\n   * @memberof Batch\n   */\n  private concurrency: number;\n\n  /**\n   * Number of active operations under execution.\n   *\n   * @private\n   * @type {number}\n   * @memberof Batch\n   */\n  private actives: number = 0;\n\n  /**\n   * Number of completed operations under execution.\n   *\n   * @private\n   * @type {number}\n   * @memberof Batch\n   */\n  private completed: number = 0;\n\n  /**\n   * Offset of next operation to be executed.\n   *\n   * @private\n   * @type {number}\n   * @memberof Batch\n   */\n  private offset: number = 0;\n\n  /**\n   * Operation array to be executed.\n   *\n   * @private\n   * @type {Operation[]}\n   * @memberof Batch\n   */\n  private operations: Operation[] = [];\n\n  /**\n   * States of Batch. When an error happens, state will turn into error.\n   * Batch will stop execute left operations.\n   *\n   * @private\n   * @type {BatchStates}\n   * @memberof Batch\n   */\n  private state: BatchStates = BatchStates.Good;\n\n  /**\n   * A private emitter used to pass events inside this class.\n   *\n   * @private\n   * @type {EventEmitter}\n   * @memberof Batch\n   */\n  private emitter: EventEmitter;\n\n  /**\n   * Creates an instance of Batch.\n   * @param {number} [concurrency=5]\n   * @memberof Batch\n   */\n  public constructor(concurrency: number = 5) {\n    if (concurrency < 1) {\n      throw new RangeError(\"concurrency must be larger than 0\");\n    }\n    this.concurrency = concurrency;\n    this.emitter = new EventEmitter();\n  }\n\n  /**\n   * Add a operation into queue.\n   *\n   * @param {Operation} operation\n   * @memberof Batch\n   */\n  public addOperation(operation: Operation): void {\n    this.operations.push(async () => {\n      try {\n        this.actives++;\n        await operation();\n        this.actives--;\n        this.completed++;\n        this.parallelExecute();\n      } catch (error) {\n        this.emitter.emit(\"error\", error);\n      }\n    });\n  }\n\n  /**\n   * Start execute operations in the queue.\n   *\n   * @returns {Promise<void>}\n   * @memberof Batch\n   */\n  public async do(): Promise<void> {\n    if (this.operations.length === 0) {\n      return Promise.resolve();\n    }\n\n    this.parallelExecute();\n\n    return new Promise<void>((resolve, reject) => {\n      this.emitter.on(\"finish\", resolve);\n\n      this.emitter.on(\"error\", (error) => {\n        this.state = BatchStates.Error;\n        reject(error);\n      });\n    });\n  }\n\n  /**\n   * Get next operation to be executed. Return null when reaching ends.\n   *\n   * @private\n   * @returns {(Operation | null)}\n   * @memberof Batch\n   */\n  private nextOperation(): Operation | null {\n    if (this.offset < this.operations.length) {\n      return this.operations[this.offset++];\n    }\n    return null;\n  }\n\n  /**\n   * Start execute operations. One one the most important difference between\n   * this method with do() is that do() wraps as an sync method.\n   *\n   * @private\n   * @returns {void}\n   * @memberof Batch\n   */\n  private parallelExecute(): void {\n    if (this.state === BatchStates.Error) {\n      return;\n    }\n\n    if (this.completed >= this.operations.length) {\n      this.emitter.emit(\"finish\");\n      return;\n    }\n\n    while (this.actives < this.concurrency) {\n      const operation = this.nextOperation();\n      if (operation) {\n        operation();\n      } else {\n        return;\n      }\n    }\n  }\n}\n"]}