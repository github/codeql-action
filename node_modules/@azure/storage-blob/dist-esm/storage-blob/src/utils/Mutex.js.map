{"version":3,"file":"Mutex.js","sourceRoot":"","sources":["../../../../src/utils/Mutex.ts"],"names":[],"mappings":";AAAA,IAAK,eAGJ;AAHD,WAAK,eAAe;IAClB,yDAAM,CAAA;IACN,6DAAQ,CAAA;AACV,CAAC,EAHI,eAAe,KAAf,eAAe,QAGnB;AAID;;;;;GAKG;AACH;IAAA;IA6DA,CAAC;IA5DC;;;;;;;;OAQG;IACiB,UAAI,GAAxB,UAAyB,GAAW;;;;gBAClC,sBAAO,IAAI,OAAO,CAAO,UAAC,OAAO;wBAC/B,IAAI,KAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,SAAS,IAAI,KAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,eAAe,CAAC,QAAQ,EAAE;4BAC/E,KAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,eAAe,CAAC,MAAM,CAAC;4BACxC,OAAO,EAAE,CAAC;yBACX;6BAAM;4BACL,KAAI,CAAC,aAAa,CAAC,GAAG,EAAE;gCACtB,KAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,eAAe,CAAC,MAAM,CAAC;gCACxC,OAAO,EAAE,CAAC;4BACZ,CAAC,CAAC,CAAC;yBACJ;oBACH,CAAC,CAAC,EAAC;;;KACJ;IAED;;;;;;;OAOG;IACiB,YAAM,GAA1B,UAA2B,GAAW;;;;gBACpC,sBAAO,IAAI,OAAO,CAAO,UAAC,OAAO;wBAC/B,IAAI,KAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,eAAe,CAAC,MAAM,EAAE;4BAC7C,KAAI,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;yBAC3B;wBACD,OAAO,KAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;wBACtB,OAAO,EAAE,CAAC;oBACZ,CAAC,CAAC,EAAC;;;KACJ;IAKc,mBAAa,GAA5B,UAA6B,GAAW,EAAE,OAAiB;QACzD,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,SAAS,EAAE;YACrC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;SACjC;aAAM;YACL,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SACnC;IACH,CAAC;IAEc,qBAAe,GAA9B,UAA+B,GAAW;QAA1C,iBAOC;QANC,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,SAAS,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;YACvE,IAAM,SAAO,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC;YAC5C,YAAY,CAAC;gBACX,SAAQ,CAAC,IAAI,CAAC,KAAI,CAAC,CAAC;YACtB,CAAC,CAAC,CAAC;SACJ;IACH,CAAC;IAlBc,UAAI,GAAuC,EAAE,CAAC;IAC9C,eAAS,GAAkC,EAAE,CAAC;IAkB/D,YAAC;CAAA,AA7DD,IA6DC;SA7DY,KAAK","sourcesContent":["enum MutexLockStatus {\n  LOCKED,\n  UNLOCKED\n}\n\ntype Callback = (...args: any[]) => any;\n\n/**\n * An async mutex lock.\n *\n * @export\n * @class Mutex\n */\nexport class Mutex {\n  /**\n   * Lock for a specific key. If the lock has been acquired by another customer, then\n   * will wait until getting the lock.\n   *\n   * @static\n   * @param {string} key lock key\n   * @returns {Promise<void>}\n   * @memberof Mutex\n   */\n  public static async lock(key: string): Promise<void> {\n    return new Promise<void>((resolve) => {\n      if (this.keys[key] === undefined || this.keys[key] === MutexLockStatus.UNLOCKED) {\n        this.keys[key] = MutexLockStatus.LOCKED;\n        resolve();\n      } else {\n        this.onUnlockEvent(key, () => {\n          this.keys[key] = MutexLockStatus.LOCKED;\n          resolve();\n        });\n      }\n    });\n  }\n\n  /**\n   * Unlock a key.\n   *\n   * @static\n   * @param {string} key\n   * @returns {Promise<void>}\n   * @memberof Mutex\n   */\n  public static async unlock(key: string): Promise<void> {\n    return new Promise<void>((resolve) => {\n      if (this.keys[key] === MutexLockStatus.LOCKED) {\n        this.emitUnlockEvent(key);\n      }\n      delete this.keys[key];\n      resolve();\n    });\n  }\n\n  private static keys: { [key: string]: MutexLockStatus } = {};\n  private static listeners: { [key: string]: Callback[] } = {};\n\n  private static onUnlockEvent(key: string, handler: Callback) {\n    if (this.listeners[key] === undefined) {\n      this.listeners[key] = [handler];\n    } else {\n      this.listeners[key].push(handler);\n    }\n  }\n\n  private static emitUnlockEvent(key: string) {\n    if (this.listeners[key] !== undefined && this.listeners[key].length > 0) {\n      const handler = this.listeners[key].shift();\n      setImmediate(() => {\n        handler!.call(this);\n      });\n    }\n  }\n}\n"]}