// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __extends } from "tslib";
import { Readable } from "stream";
/**
 * This class generates a readable stream from the data in an array of buffers.
 *
 * @export
 * @class BuffersStream
 */
var BuffersStream = /** @class */ (function (_super) {
    __extends(BuffersStream, _super);
    /**
     * Creates an instance of BuffersStream that will emit the data
     * contained in the array of buffers.
     *
     * @param {Buffer[]} buffers Array of buffers containing the data
     * @param {number} byteLength The total length of data contained in the buffers
     * @memberof BuffersStream
     */
    function BuffersStream(buffers, byteLength, options) {
        var _this = _super.call(this, options) || this;
        _this.buffers = buffers;
        _this.byteLength = byteLength;
        _this.byteOffsetInCurrentBuffer = 0;
        _this.bufferIndex = 0;
        _this.pushedBytesLength = 0;
        // check byteLength is no larger than buffers[] total length
        var buffersLength = 0;
        for (var _i = 0, _a = _this.buffers; _i < _a.length; _i++) {
            var buf = _a[_i];
            buffersLength += buf.byteLength;
        }
        if (buffersLength < _this.byteLength) {
            throw new Error("Data size shouldn't be larger than the total length of buffers.");
        }
        return _this;
    }
    /**
     * Internal _read() that will be called when the stream wants to pull more data in.
     *
     * @param {number} size Optional. The size of data to be read
     * @memberof BuffersStream
     */
    BuffersStream.prototype._read = function (size) {
        if (this.pushedBytesLength >= this.byteLength) {
            this.push(null);
        }
        if (!size) {
            size = this.readableHighWaterMark;
        }
        var outBuffers = [];
        var i = 0;
        while (i < size && this.pushedBytesLength < this.byteLength) {
            // The last buffer may be longer than the data it contains.
            var remainingDataInAllBuffers = this.byteLength - this.pushedBytesLength;
            var remainingCapacityInThisBuffer = this.buffers[this.bufferIndex].byteLength - this.byteOffsetInCurrentBuffer;
            var remaining = Math.min(remainingCapacityInThisBuffer, remainingDataInAllBuffers);
            if (remaining > size - i) {
                // chunkSize = size - i
                var end = this.byteOffsetInCurrentBuffer + size - i;
                outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
                this.pushedBytesLength += size - i;
                this.byteOffsetInCurrentBuffer = end;
                i = size;
                break;
            }
            else {
                // chunkSize = remaining
                var end = this.byteOffsetInCurrentBuffer + remaining;
                outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
                if (remaining === remainingCapacityInThisBuffer) {
                    // this.buffers[this.bufferIndex] used up, shift to next one
                    this.byteOffsetInCurrentBuffer = 0;
                    this.bufferIndex++;
                }
                else {
                    this.byteOffsetInCurrentBuffer = end;
                }
                this.pushedBytesLength += remaining;
                i += remaining;
            }
        }
        if (outBuffers.length > 1) {
            this.push(Buffer.concat(outBuffers));
        }
        else if (outBuffers.length === 1) {
            this.push(outBuffers[0]);
        }
    };
    return BuffersStream;
}(Readable));
export { BuffersStream };
//# sourceMappingURL=BuffersStream.js.map