{"version":3,"file":"AvroParser.js","sourceRoot":"","sources":["../../../../storage-internal-avro/src/AvroParser.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AvroReadable } from \"./AvroReadable\";\nimport { KeyValuePair } from \"./utils/utils.common\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\n\n/**\n * Options to configure the AvroParser read methods.\n * See {@link AvroParser.readFixedBytes}, {@link AvroParser.readMap} and etc.\n *\n * @export\n * @interface AvroParserReadOptions\n */\ninterface AvroParserReadOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof AvroParserReadOptions\n   */\n  abortSignal?: AbortSignalLike;\n}\n\nexport class AvroParser {\n  /**\n   * Reads a fixed number of bytes from the stream.\n   *\n   * @static\n   * @param {AvroReadable} [stream]\n   * @param {number} [length]\n   * @param {AvroParserReadOptions} [options={}]\n   * @returns {Promise<Uint8Array>}\n   * @memberof AvroParser\n   */\n  public static async readFixedBytes(\n    stream: AvroReadable,\n    length: number,\n    options: AvroParserReadOptions = {}\n  ): Promise<Uint8Array> {\n    const bytes = await stream.read(length, { abortSignal: options.abortSignal });\n    if (bytes.length != length) {\n      throw new Error(\"Hit stream end.\");\n    }\n    return bytes;\n  }\n\n  /**\n   * Reads a single byte from the stream.\n   *\n   * @static\n   * @param {AvroReadable} [stream]\n   * @param {AvroParserReadOptions} [options={}]\n   * @returns {Promise<number>}\n   * @memberof AvroParser\n   */\n  private static async readByte(\n    stream: AvroReadable,\n    options: AvroParserReadOptions = {}\n  ): Promise<number> {\n    const buf = await AvroParser.readFixedBytes(stream, 1, options);\n    return buf[0];\n  }\n\n  // int and long are stored in variable-length zig-zag coding.\n  // variable-length: https://lucene.apache.org/core/3_5_0/fileformats.html#VInt\n  // zig-zag: https://developers.google.com/protocol-buffers/docs/encoding?csw=1#types\n  private static async readZigZagLong(\n    stream: AvroReadable,\n    options: AvroParserReadOptions = {}\n  ): Promise<number> {\n    let zigZagEncoded = 0;\n    let significanceInBit = 0;\n    let byte, haveMoreByte, significanceInFloat;\n\n    do {\n      byte = await AvroParser.readByte(stream, options);\n      haveMoreByte = byte & 0x80;\n      zigZagEncoded |= (byte & 0x7f) << significanceInBit;\n      significanceInBit += 7;\n    } while (haveMoreByte && significanceInBit < 28); // bitwise operation only works for 32-bit integers\n\n    if (haveMoreByte) {\n      // Switch to float arithmetic\n      zigZagEncoded = zigZagEncoded;\n      significanceInFloat = 268435456; // 2 ** 28.\n      do {\n        byte = await AvroParser.readByte(stream, options);\n        zigZagEncoded += (byte & 0x7f) * significanceInFloat;\n        significanceInFloat *= 128; // 2 ** 7\n      } while (byte & 0x80);\n\n      const res = (zigZagEncoded % 2 ? -(zigZagEncoded + 1) : zigZagEncoded) / 2;\n      if (res < Number.MIN_SAFE_INTEGER || res > Number.MAX_SAFE_INTEGER) {\n        throw new Error(\"Integer overflow.\");\n      }\n      return res;\n    }\n\n    return (zigZagEncoded >> 1) ^ -(zigZagEncoded & 1);\n  }\n\n  public static async readLong(\n    stream: AvroReadable,\n    options: AvroParserReadOptions = {}\n  ): Promise<number> {\n    return AvroParser.readZigZagLong(stream, options);\n  }\n\n  public static async readInt(\n    stream: AvroReadable,\n    options: AvroParserReadOptions = {}\n  ): Promise<number> {\n    return AvroParser.readZigZagLong(stream, options);\n  }\n\n  public static async readNull(): Promise<null> {\n    return null;\n  }\n\n  public static async readBoolean(\n    stream: AvroReadable,\n    options: AvroParserReadOptions = {}\n  ): Promise<Boolean> {\n    const b = await AvroParser.readByte(stream, options);\n    if (b == 1) {\n      return true;\n    } else if (b == 0) {\n      return false;\n    } else {\n      throw new Error(\"Byte was not a boolean.\");\n    }\n  }\n\n  public static async readFloat(\n    stream: AvroReadable,\n    options: AvroParserReadOptions = {}\n  ): Promise<number> {\n    const u8arr = await AvroParser.readFixedBytes(stream, 4, options);\n    const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);\n    return view.getFloat32(0, true); // littleEndian = true\n  }\n\n  public static async readDouble(\n    stream: AvroReadable,\n    options: AvroParserReadOptions = {}\n  ): Promise<number> {\n    const u8arr = await AvroParser.readFixedBytes(stream, 8, options);\n    const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);\n    return view.getFloat64(0, true); // littleEndian = true\n  }\n\n  public static async readBytes(\n    stream: AvroReadable,\n    options: AvroParserReadOptions = {}\n  ): Promise<Uint8Array> {\n    const size = await AvroParser.readLong(stream, options);\n    if (size < 0) {\n      throw new Error(\"Bytes size was negative.\");\n    }\n\n    return await stream.read(size, { abortSignal: options.abortSignal });\n  }\n\n  public static async readString(\n    stream: AvroReadable,\n    options: AvroParserReadOptions = {}\n  ): Promise<string> {\n    const u8arr = await AvroParser.readBytes(stream, options);\n\n    // polyfill TextDecoder to be backward compatible with older\n    // nodejs that doesn't expose TextDecoder as a global variable\n    if (typeof TextDecoder === \"undefined\" && typeof require !== \"undefined\") {\n      (global as any).TextDecoder = require(\"util\").TextDecoder;\n    }\n\n    // FUTURE: need TextDecoder polyfill for IE\n    let utf8decoder = new TextDecoder();\n    return utf8decoder.decode(u8arr);\n  }\n\n  private static async readMapPair<T>(\n    stream: AvroReadable,\n    readItemMethod: (s: AvroReadable, options?: AvroParserReadOptions) => Promise<T>,\n    options: AvroParserReadOptions = {}\n  ): Promise<KeyValuePair<T>> {\n    const key = await AvroParser.readString(stream, options);\n    // FUTURE: this won't work with readFixed (currently not supported) which needs a length as the parameter.\n    const value = await readItemMethod(stream, options);\n    return { key, value };\n  }\n\n  public static async readMap<T>(\n    stream: AvroReadable,\n    readItemMethod: (s: AvroReadable, options?: AvroParserReadOptions) => Promise<T>,\n    options: AvroParserReadOptions = {}\n  ): Promise<Record<string, T>> {\n    const readPairMethod = async (\n      stream: AvroReadable,\n      options: AvroParserReadOptions = {}\n    ): Promise<KeyValuePair<T>> => {\n      return await AvroParser.readMapPair(stream, readItemMethod, options);\n    };\n\n    const pairs: KeyValuePair<T>[] = await AvroParser.readArray(stream, readPairMethod, options);\n\n    let dict: Record<string, T> = {};\n    for (const pair of pairs) {\n      dict[pair.key] = pair.value;\n    }\n    return dict;\n  }\n\n  private static async readArray<T>(\n    stream: AvroReadable,\n    readItemMethod: (s: AvroReadable, options?: AvroParserReadOptions) => Promise<T>,\n    options: AvroParserReadOptions = {}\n  ): Promise<T[]> {\n    let items: T[] = [];\n    for (\n      let count = await AvroParser.readLong(stream, options);\n      count != 0;\n      count = await AvroParser.readLong(stream, options)\n    ) {\n      if (count < 0) {\n        // Ignore block sizes\n        await AvroParser.readLong(stream, options);\n        count = -count;\n      }\n\n      while (count--) {\n        const item: T = await readItemMethod(stream, options);\n        items.push(item);\n      }\n    }\n    return items;\n  }\n}\n\ninterface RecordField {\n  name: string;\n  type: string | ObjectSchema | (string | ObjectSchema)[]; // Unions may not immediately contain other unions.\n}\n\nenum AvroComplex {\n  RECORD = \"record\",\n  ENUM = \"enum\",\n  ARRAY = \"array\",\n  MAP = \"map\",\n  UNION = \"union\",\n  FIXED = \"fixed\"\n}\n\ninterface ObjectSchema {\n  type: Exclude<AvroComplex, AvroComplex.UNION>;\n  name?: string;\n  aliases?: string;\n  fields?: RecordField[];\n  symbols?: string[];\n  values?: string;\n  size?: number;\n}\n\nexport abstract class AvroType {\n  /**\n   * Reads an object from the stream.\n   *\n   * @param stream\n   */\n  public abstract read(\n    stream: AvroReadable,\n    options?: AvroParserReadOptions\n  ): Promise<Object | null>;\n\n  /**\n   * Determines the AvroType from the Avro Schema.\n   */\n  public static fromSchema(schema: string | Object): AvroType {\n    if (typeof schema == \"string\") {\n      return AvroType.fromStringSchema(schema);\n    } else if (Array.isArray(schema)) {\n      return AvroType.fromArraySchema(schema);\n    } else {\n      return AvroType.fromObjectSchema(schema as ObjectSchema);\n    }\n  }\n\n  private static fromStringSchema(schema: string): AvroType {\n    switch (schema) {\n      case AvroPrimitive.NULL:\n      case AvroPrimitive.BOOLEAN:\n      case AvroPrimitive.INT:\n      case AvroPrimitive.LONG:\n      case AvroPrimitive.FLOAT:\n      case AvroPrimitive.DOUBLE:\n      case AvroPrimitive.BYTES:\n      case AvroPrimitive.STRING:\n        return new AvroPrimitiveType(schema as AvroPrimitive);\n      default:\n        throw new Error(`Unexpected Avro type ${schema}`);\n    }\n  }\n\n  private static fromArraySchema(schema: any[]): AvroType {\n    return new AvroUnionType(schema.map(AvroType.fromSchema));\n  }\n\n  private static fromObjectSchema(schema: ObjectSchema): AvroType {\n    const type = schema.type;\n    // Primitives can be defined as strings or objects\n    try {\n      return AvroType.fromStringSchema(type);\n    } catch (err) {}\n\n    switch (type) {\n      case AvroComplex.RECORD:\n        if (schema.aliases) {\n          throw new Error(`aliases currently is not supported, schema: ${schema}`);\n        }\n        if (!schema.name) {\n          throw new Error(`Required attribute 'name' doesn't exist on schema: ${schema}`);\n        }\n\n        let fields: Record<string, AvroType> = {};\n        if (!schema.fields) {\n          throw new Error(`Required attribute 'fields' doesn't exist on schema: ${schema}`);\n        }\n        for (const field of schema.fields) {\n          fields[field.name] = AvroType.fromSchema(field.type);\n        }\n        return new AvroRecordType(fields, schema.name);\n      case AvroComplex.ENUM:\n        if (schema.aliases) {\n          throw new Error(`aliases currently is not supported, schema: ${schema}`);\n        }\n        if (!schema.symbols) {\n          throw new Error(`Required attribute 'symbols' doesn't exist on schema: ${schema}`);\n        }\n        return new AvroEnumType(schema.symbols);\n      case AvroComplex.MAP:\n        if (!schema.values) {\n          throw new Error(`Required attribute 'values' doesn't exist on schema: ${schema}`);\n        }\n        return new AvroMapType(AvroType.fromSchema(schema.values));\n      case AvroComplex.ARRAY: // Unused today\n      case AvroComplex.FIXED: // Unused today\n      default:\n        throw new Error(`Unexpected Avro type ${type} in ${schema}`);\n    }\n  }\n}\n\nenum AvroPrimitive {\n  NULL = \"null\",\n  BOOLEAN = \"boolean\",\n  INT = \"int\",\n  LONG = \"long\",\n  FLOAT = \"float\",\n  DOUBLE = \"double\",\n  BYTES = \"bytes\",\n  STRING = \"string\"\n}\n\nclass AvroPrimitiveType extends AvroType {\n  private _primitive: AvroPrimitive;\n\n  constructor(primitive: AvroPrimitive) {\n    super();\n    this._primitive = primitive;\n  }\n\n  public async read(\n    stream: AvroReadable,\n    options: AvroParserReadOptions = {}\n  ): Promise<Object | null> {\n    switch (this._primitive) {\n      case AvroPrimitive.NULL:\n        return await AvroParser.readNull();\n      case AvroPrimitive.BOOLEAN:\n        return await AvroParser.readBoolean(stream, options);\n      case AvroPrimitive.INT:\n        return await AvroParser.readInt(stream, options);\n      case AvroPrimitive.LONG:\n        return await AvroParser.readLong(stream, options);\n      case AvroPrimitive.FLOAT:\n        return await AvroParser.readFloat(stream, options);\n      case AvroPrimitive.DOUBLE:\n        return await AvroParser.readDouble(stream, options);\n      case AvroPrimitive.BYTES:\n        return await AvroParser.readBytes(stream, options);\n      case AvroPrimitive.STRING:\n        return await AvroParser.readString(stream, options);\n      default:\n        throw new Error(\"Unknown Avro Primitive\");\n    }\n  }\n}\n\nclass AvroEnumType extends AvroType {\n  private readonly _symbols: string[];\n\n  constructor(symbols: string[]) {\n    super();\n    this._symbols = symbols;\n  }\n\n  public async read(stream: AvroReadable, options: AvroParserReadOptions = {}): Promise<Object> {\n    const value = await AvroParser.readInt(stream, options);\n    return this._symbols[value];\n  }\n}\n\nclass AvroUnionType extends AvroType {\n  private readonly _types: AvroType[];\n\n  constructor(types: AvroType[]) {\n    super();\n    this._types = types;\n  }\n\n  public async read(\n    stream: AvroReadable,\n    options: AvroParserReadOptions = {}\n  ): Promise<Object | null> {\n    const typeIndex = await AvroParser.readInt(stream, options);\n    return await this._types[typeIndex].read(stream, options);\n  }\n}\n\nclass AvroMapType extends AvroType {\n  private readonly _itemType: AvroType;\n\n  constructor(itemType: AvroType) {\n    super();\n    this._itemType = itemType;\n  }\n\n  public async read(stream: AvroReadable, options: AvroParserReadOptions = {}): Promise<Object> {\n    const readItemMethod = async (\n      s: AvroReadable,\n      options?: AvroParserReadOptions\n    ): Promise<Object | null> => {\n      return await this._itemType.read(s, options);\n    };\n    return await AvroParser.readMap(stream, readItemMethod, options);\n  }\n}\n\nclass AvroRecordType extends AvroType {\n  private readonly _name: string;\n  private readonly _fields: Record<string, AvroType>;\n\n  constructor(fields: Record<string, AvroType>, name: string) {\n    super();\n    this._fields = fields;\n    this._name = name;\n  }\n\n  public async read(stream: AvroReadable, options: AvroParserReadOptions = {}): Promise<Object> {\n    let record: Record<string, Object | null> = {};\n    record[\"$schema\"] = this._name;\n    for (const key in this._fields) {\n      if (this._fields.hasOwnProperty(key)) {\n        record[key] = await this._fields[key].read(stream, options);\n      }\n    }\n    return record;\n  }\n}\n"]}